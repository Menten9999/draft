<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>管理者ページ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .reset-button { background-color: #dc3545; margin-left: 15px; }
        .reset-button:hover { background-color: #c82333; }
    </style>
</head>
<body>
<main class="main">
    <h1 class="title">ドラフト管理画面</h1>
    <div class="container">
        <div class="status-section">
            <h2>現在選択中の選手 (第<span id="round-number">1</span>巡)</h2>
            <ul id="current-selection-list"></ul>
        </div>
        <div class="acquired-section">
            <h2>各チーム獲得選手一覧</h2>
            <ul id="acquired-players-list"></ul>
        </div>
    </div>
    <div class="controls">
        <button onclick="processSelectionsAndLottery()">選択を処理（競合時は抽選）</button>
        <button onclick="resetAllData()" class="reset-button">ドラフトをリセット</button>
    </div>
</main>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script src="firebase-config.js"></script>

<script>
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const teams = ['team1', 'team2']; 

    const roundRef = database.ref('round');
    const currentSelectionsRef = database.ref('currentSelections');
    const acquiredPlayersRef = database.ref('acquiredPlayers');
    const teamStatusRef = database.ref('teamStatus');
    // ★★★ 全ページに警告を送るためのRefを追加 ★★★
    const systemAlertRef = database.ref('systemAlert');

    // (中略... 表示更新のロジックは変更なし)
    roundRef.on('value', snapshot => { /* ... */ });
    currentSelectionsRef.on('value', snapshot => { /* ... */ });
    acquiredPlayersRef.on('value', snapshot => { /* ... */ });

    // ★★★ メインの抽選処理関数を修正 ★★★
    async function processSelectionsAndLottery() {
        const selectionsSnapshot = await currentSelectionsRef.once('value');
        const selections = selectionsSnapshot.val();

        if (!selections || Object.keys(selections).length < teams.length) {
            alert("全チームが選手を選択していません。");
            return;
        }

        // 選手ごとに選択したチームをグループ化
        const playerToTeams = {};
        for (const teamId in selections) {
            const player = selections[teamId];
            if (!playerToTeams[player]) playerToTeams[player] = [];
            playerToTeams[player].push(teamId);
        }

        const conflicts = {};
        const nonConflicts = {};
        for (const player in playerToTeams) {
            if (playerToTeams[player].length > 1) {
                conflicts[player] = playerToTeams[player];
            } else {
                nonConflicts[player] = playerToTeams[player];
            }
        }

        // --- 競合がある場合の処理を修正 ---
        if (Object.keys(conflicts).length > 0) {
            // 1. 全ページに警告を表示させる
            await systemAlertRef.set("競合が発生しました。ただいまから抽選を行います...");

            // 2. 管理者に最終確認
            if (!confirm("競合が発生しました。抽選に移行しますか？")) {
                await systemAlertRef.remove(); // キャンセルされたら警告を消す
                alert("抽選はキャンセルされました。");
                return;
            }

            // 3. 抽選処理を実行
            let alertLog = "抽選結果：\n";
            for (const player in conflicts) {
                const competingTeams = conflicts[player];
                const winner = competingTeams[Math.floor(Math.random() * competingTeams.length)];
                
                alertLog += `\n[選手: ${player}] -> 当選: ${winner}！\n`;

                await acquiredPlayersRef.child(winner).push(player);
                for (const teamId of competingTeams) {
                    const message = (teamId === winner) 
                        ? `「${player}」の抽選に当選しました！`
                        : `「${player}」の抽選に外れました。再度選択してください。`;
                    await teamStatusRef.child(teamId).set(message);
                }
            }
             alert(alertLog);
        } else {
            alert("競合はありませんでした。全チームの選択を確定します。");
        }
        
        // 単独指名の処理
        for (const player in nonConflicts) {
            const teamId = nonConflicts[player][0];
            await acquiredPlayersRef.child(teamId).push(player);
            await teamStatusRef.child(teamId).set(`「${player}」を単独指名で獲得しました。`);
        }
        
        // 全チームの現在の選択をクリア
        await currentSelectionsRef.remove();
        // 警告メッセージをクリア
        await systemAlertRef.remove();

        // 巡目を進めるかどうかの判定
        if (Object.keys(conflicts).length === 0) {
            const roundSnapshot = await roundRef.once('value');
            const nextRound = (roundSnapshot.val() || 1) + 1;
            await roundRef.set(nextRound);
            await teamStatusRef.remove();
        }
    }
    
    // リセット機能 (変更なし)
    async function resetAllData() { /* ... */ }
</script>
</body>
</html>