<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>管理者ページ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .reset-button { background-color: #dc3545; margin-left: 15px; }
        .reset-button:hover { background-color: #c82333; }
    </style>
</head>
<body>
<main class="main">
    <h1 class="title">ドラフト管理画面</h1>
    <div class="container">
        <div class="status-section">
            <h2>現在選択中の選手 (第<span id="round-number">1</span>巡)</h2>
            <ul id="current-selection-list"></ul>
        </div>
        <div class="acquired-section">
            <h2>各チーム獲得選手一覧</h2>
            <ul id="acquired-players-list"></ul>
        </div>
    </div>
    <div class="controls">
        <button onclick="processSelectionsAndLottery()">選択を処理（競合時は抽選）</button>
        <button onclick="resetAllData()" class="reset-button">ドラフトをリセット</button>
    </div>
</main>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script src="firebase-config.js"></script>
<script>
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const teams = ['team1', 'team2']; 

    const roundRef = database.ref('round');
    const currentSelectionsRef = database.ref('currentSelections');
    const acquiredPlayersRef = database.ref('acquiredPlayers');
    const teamStatusRef = database.ref('teamStatus');
    const systemAlertRef = database.ref('systemAlert');
    // ★★★ 選手確定状態を管理するRefを追加 ★★★
    const selectionConfirmedRef = database.ref('selectionConfirmed');
        const teamsPassedRef = database.ref('teamsPassed');


    // (表示更新のロジックは変更なし)
roundRef.on('value', snapshot => {
        document.getElementById('round-number').textContent = snapshot.val() || 1;
    });

    // 現在の選択状況の変更を監視して表示を更新
    currentSelectionsRef.on('value', snapshot => {
        const list = document.getElementById('current-selection-list');
        list.innerHTML = '';
        const selections = snapshot.val() || {};
        teams.forEach(team => {
            const player = selections[team] || '未選択';
            const teamName = (team === 'team1') ? 'チーム1' : 'チーム2';
            const li = document.createElement('li');
            li.textContent = `${teamName}: ${player}`;
            list.appendChild(li);
        });
    });

    // 獲得済み選手の変更を監視して表示を更新
    acquiredPlayersRef.on('value', snapshot => {
        const list = document.getElementById('acquired-players-list');
        list.innerHTML = '';
        const allAcquired = snapshot.val() || {};
        teams.forEach(team => {
            const teamName = (team === 'team1') ? 'チーム1' : 'チーム2';
            const players = allAcquired[team] ? Object.values(allAcquired[team]).join(', ') : 'なし';
            const li = document.createElement('li');
            li.textContent = `${teamName}: ${players}`;
            list.appendChild(li);
        });
    });

 // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    async function processSelectionsAndLottery() {
        const selectionsSnapshot = await currentSelectionsRef.once('value');
        const selections = selectionsSnapshot.val() || {};
        const confirmedSnapshot = await selectionConfirmedRef.once('value');
        const confirmed = confirmedSnapshot.val() || {};
                const passedSnapshot = await teamsPassedRef.once('value');
        const passed = passedSnapshot.val() || {};

        const activeTeams = teams.filter(team => !confirmed[team] && !passed[team]);
        
        if (Object.keys(selections).length < activeTeams.length) {
            alert("まだ選択を終えていないチームがいます。");
            return;
        }

        const playerToTeams = {};
        for (const teamId in selections) {
            const player = selections[teamId];
            if (!playerToTeams[player]) playerToTeams[player] = [];
            playerToTeams[player].push(teamId);
        }

        const conflicts = {};
        const nonConflicts = {};
        for (const player in playerToTeams) {
            if (playerToTeams[player].length > 1) {
                conflicts[player] = playerToTeams[player];
            } else {
                nonConflicts[player] = playerToTeams[player];
            }
        }

        if (Object.keys(conflicts).length > 0) {
            await systemAlertRef.set("競合が発生しました。ただいまから抽選を行います...");
            if (!confirm("競合が発生しました。抽選に移行しますか？")) {
                await systemAlertRef.remove();
                alert("抽選はキャンセルされました。");
                return;
            }

            let alertLog = "抽選結果：\n";
            for (const player in conflicts) {
                const competingTeams = conflicts[player];
                const winner = competingTeams[Math.floor(Math.random() * competingTeams.length)];
                
                alertLog += `\n[選手: ${player}] -> 当選: ${winner}！\n`;

                await acquiredPlayersRef.child(winner).push(player);
                for (const teamId of competingTeams) {
                    if (teamId === winner) {
                        await teamStatusRef.child(teamId).set("交渉権獲得");
                        await selectionConfirmedRef.child(teamId).set(true);
                    } else {
                        await teamStatusRef.child(teamId).set("落選しました。再度選手を選択してください");
                    }
                }
            }
             alert(alertLog);
        } else {
            alert("競合はありませんでした。全チームの選択を確定します。");
        }
        
        for (const player in nonConflicts) {
            const teamId = nonConflicts[player][0];
            await acquiredPlayersRef.child(teamId).push(player);
            await teamStatusRef.child(teamId).set("交渉権獲得");
            await selectionConfirmedRef.child(teamId).set(true);
        }
        
        await currentSelectionsRef.remove();
        await systemAlertRef.remove();

        // ★★★ 変数名のタイプミスを修正し、巡目更新ロジックをここに集約 ★★★
       const finalConfirmedSnapshot = await selectionConfirmedRef.once('value');
        const finalPassedSnapshot = await teamsPassedRef.once('value');
        const finalConfirmedCount = finalConfirmedSnapshot.val() ? Object.keys(finalConfirmedSnapshot.val()).length : 0;
        const finalPassedCount = finalPassedSnapshot.val() ? Object.keys(finalPassedSnapshot.val()).length : 0;
        
        // 確定チーム数と辞退チーム数の合計が全チーム数と一致したら次巡へ
        if (finalConfirmedCount + finalPassedCount === teams.length) {
            const roundSnapshot = await roundRef.once('value');
            const nextRound = (roundSnapshot.val() || 1) + 1;
            
            await roundRef.set(nextRound);
            await teamStatusRef.remove();
            await selectionConfirmedRef.remove(); // 辞退していないチームの確定状態のみリセット
            
            alert(`全アクティブチームの選択が確定しました。第${nextRound}巡に移行します。`);
        }
    }
        
    // リセット機能 (変更なし)
    async function resetAllData() {
        const confirmationText = "delete";
        const userInput = prompt(`警告：すべてのドラフトデータが完全に削除されます。「${confirmationText}」と入力してください。`);
        if (userInput === confirmationText) {
            await database.ref().set(null);
            await roundRef.set(1);
            alert("ドラフトデータが初期化されました。");
        } else if (userInput !== null) {
            alert("入力が間違っています。");
        }
    }
</script>
</body>
</html>