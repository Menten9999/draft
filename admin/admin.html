<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>管理者ページ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .reset-button { background-color: #dc3545; margin-left: 15px; }
        .reset-button:hover { background-color: #c82333; }
    </style>
</head>
<body>
<main class="main">
    <h1 class="title">ドラフト管理画面</h1>
    <div class="container">
        <div class="status-section">
            <h2>現在選択中の選手 (第<span id="round-number">1</span>巡)</h2>
            <ul id="current-selection-list"></ul>
        </div>
        <div class="acquired-section">
            <h2>各チーム獲得選手一覧</h2>
            <ul id="acquired-players-list"></ul>
        </div>
    </div>
    <div class="controls">
        <button onclick="processSelectionsAndLottery()">選択を処理（競合時は抽選）</button>
        <button onclick="resetAllData()" class="reset-button">ドラフトをリセット</button>
    </div>
</main>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script src="firebase-config.js"></script>
<script>
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const teams = ['team1', 'team2']; 

    const roundRef = database.ref('round');
    const currentSelectionsRef = database.ref('currentSelections');
    const acquiredPlayersRef = database.ref('acquiredPlayers');
    const teamStatusRef = database.ref('teamStatus');
    const systemAlertRef = database.ref('systemAlert');
    // ★★★ 選手確定状態を管理するRefを追加 ★★★
    const selectionConfirmedRef = database.ref('selectionConfirmed');

    // (表示更新のロジックは変更なし)
roundRef.on('value', snapshot => {
        document.getElementById('round-number').textContent = snapshot.val() || 1;
    });

    // 現在の選択状況の変更を監視して表示を更新
    currentSelectionsRef.on('value', snapshot => {
        const list = document.getElementById('current-selection-list');
        list.innerHTML = '';
        const selections = snapshot.val() || {};
        teams.forEach(team => {
            const player = selections[team] || '未選択';
            const teamName = (team === 'team1') ? 'チーム1' : 'チーム2';
            const li = document.createElement('li');
            li.textContent = `${teamName}: ${player}`;
            list.appendChild(li);
        });
    });

    // 獲得済み選手の変更を監視して表示を更新
    acquiredPlayersRef.on('value', snapshot => {
        const list = document.getElementById('acquired-players-list');
        list.innerHTML = '';
        const allAcquired = snapshot.val() || {};
        teams.forEach(team => {
            const teamName = (team === 'team1') ? 'チーム1' : 'チーム2';
            const players = allAcquired[team] ? Object.values(allAcquired[team]).join(', ') : 'なし';
            const li = document.createElement('li');
            li.textContent = `${teamName}: ${players}`;
            list.appendChild(li);
        });
    });

    async function processSelectionsAndLottery() {
        const selectionsSnapshot = await currentSelectionsRef.once('value');
        const selections = selectionsSnapshot.val();

        if (!selections || Object.keys(selections).length < teams.length) {
            alert("全チームが選手を選択していません。");
            return;
        }

        const playerToTeams = {};
        for (const teamId in selections) {
            const player = selections[teamId];
            if (!playerToTeams[player]) playerToTeams[player] = [];
            playerToTeams[player].push(teamId);
        }

        const conflicts = {};
        const nonConflicts = {};
        for (const player in playerToTeams) {
            if (playerToTeams[player].length > 1) {
                conflicts[player] = playerToTeams[player];
            } else {
                nonConflicts[player] = playerToTeams[player];
            }
        }

        if (Object.keys(conflicts).length > 0) {
            await systemAlertRef.set("競合が発生しました。ただいまから抽選を行います...");
            if (!confirm("競合が発生しました。抽選に移行しますか？")) {
                await systemAlertRef.remove();
                alert("抽選はキャンセルされました。");
                return;
            }

            let alertLog = "抽選結果：\n";
            for (const player in conflicts) {
                const competingTeams = conflicts[player];
                const winner = competingTeams[Math.floor(Math.random() * competingTeams.length)];
                
                alertLog += `\n[選手: ${player}] -> 当選: ${winner}！\n`;

                await acquiredPlayersRef.child(winner).push(player);
                for (const teamId of competingTeams) {
                    // ★★★ メッセージとステータスを修正 ★★★
                    if (teamId === winner) {
                        await teamStatusRef.child(teamId).set("交渉権獲得");
                        await selectionConfirmedRef.child(teamId).set(true); // 確定状態にする
                    } else {
                        await teamStatusRef.child(teamId).set("落選しました。再度選手を選択してください");
                    }
                }
            }
             alert(alertLog);
        } else {
            alert("競合はありませんでした。全チームの選択を確定します。");
        }
        
        // 単独指名の処理
        for (const player in nonConflicts) {
            const teamId = nonConflicts[player][0];
            await acquiredPlayersRef.child(teamId).push(player);
            // ★★★ メッセージとステータスを修正 ★★★
            await teamStatusRef.child(teamId).set("交渉権獲得");
            await selectionConfirmedRef.child(teamId).set(true); // 確定状態にする
        }
        
        await currentSelectionsRef.remove();
        await systemAlertRef.remove();

        // 巡目を進めるかどうかの判定
        const confirmedSnapshot = await selectionConfirmedRef.once('value');
        // 全チームの選択が確定したら次巡へ
        if (confirmedSnapshot.val() && Object.keys(confirmedSnapshot.val()).length === teams.length) {
            const roundSnapshot = await roundRef.once('value');
            const nextRound = (roundSnapshot.val() || 1) + 1;
            await roundRef.set(nextRound);
            await teamStatusRef.remove();
            await selectionConfirmedRef.remove(); // 全員の確定状態をリセット
            alert(`全チームの選択が確定しました。第${nextRound}巡に移行します。`);
        }
    }
    
    // リセット機能 (変更なし)
    async function resetAllData() { /* ... */ }
</script>
</body>
</html>