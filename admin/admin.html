<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>管理者ページ</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .reset-button { background-color: #dc3545; margin-left: 15px; }
        .reset-button:hover { background-color: #c82333; }
    </style>
</head>
<body>
<main class="main">
    <h1 class="title">ドラフト管理画面</h1>
    <div class="container">
        <div class="status-section">
            <h2>現在選択中の選手 (第<span id="round-number">1</span>巡)</h2>
            <ul id="current-selection-list"></ul>
        </div>
        <div class="acquired-section">
            <h2>各チーム獲得選手一覧</h2>
            <ul id="acquired-players-list"></ul>
        </div>
    </div>
    <div class="controls">
        <button onclick="processSelectionsAndLottery()">選択を処理（競合時は抽選）</button>
        <button onclick="resetAllData()" class="reset-button">ドラフトをリセット</button>
    </div>
</main>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script src="firebase-config.js"></script>

<script>
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    // チームリストにteam2を追加 (必要に応じてさらに追加)
    const teams = ['team1', 'team2']; 

    const roundRef = database.ref('round');
    const currentSelectionsRef = database.ref('currentSelections');
    const acquiredPlayersRef = database.ref('acquiredPlayers');
    const teamStatusRef = database.ref('teamStatus');

    // 表示更新のロジック (変更なし)
    roundRef.on('value', snapshot => {
        document.getElementById('round-number').textContent = snapshot.val() || 1;
    });
    currentSelectionsRef.on('value', snapshot => {
        const list = document.getElementById('current-selection-list');
        list.innerHTML = '';
        const selections = snapshot.val() || {};
        teams.forEach(team => {
            const player = selections[team] || '未選択';
            const teamName = (team === 'team1') ? 'チーム1' : 'チーム2'; // チーム名表示を調整
            const li = document.createElement('li');
            li.textContent = `${teamName}: ${player}`;
            list.appendChild(li);
        });
    });
    acquiredPlayersRef.on('value', snapshot => {
        const list = document.getElementById('acquired-players-list');
        list.innerHTML = '';
        const allAcquired = snapshot.val() || {};
        teams.forEach(team => {
            const teamName = (team === 'team1') ? 'チーム1' : 'チーム2';
            const players = allAcquired[team] ? Object.values(allAcquired[team]).join(', ') : 'なし';
            const li = document.createElement('li');
            li.textContent = `${teamName}: ${players}`;
            list.appendChild(li);
        });
    });

    // ★★★ メインの抽選処理関数 ★★★
    async function processSelectionsAndLottery() {
        const selectionsSnapshot = await currentSelectionsRef.once('value');
        const selections = selectionsSnapshot.val();

        if (!selections || Object.keys(selections).length < teams.length) {
            alert("全チームが選手を選択していません。");
            return;
        }

        // 選手ごとに選択したチームをグループ化
        const playerToTeams = {};
        for (const teamId in selections) {
            const player = selections[teamId];
            if (!playerToTeams[player]) playerToTeams[player] = [];
            playerToTeams[player].push(teamId);
        }

        const conflicts = {};
        const nonConflicts = {};
        for (const player in playerToTeams) {
            if (playerToTeams[player].length > 1) {
                conflicts[player] = playerToTeams[player];
            } else {
                nonConflicts[player] = playerToTeams[player];
            }
        }
        
        let alertLog = "";

        // 単独指名の処理
        for (const player in nonConflicts) {
            const teamId = nonConflicts[player][0];
            await acquiredPlayersRef.child(teamId).push(player);
            await teamStatusRef.child(teamId).set(`「${player}」を単独指名で獲得しました。`);
        }

        // 競合指名（抽選）の処理
        if (Object.keys(conflicts).length > 0) {
            alertLog += "以下の選手で競合が発生したため、抽選を行います。\n";
            for (const player in conflicts) {
                const competingTeams = conflicts[player];
                const winner = competingTeams[Math.floor(Math.random() * competingTeams.length)];
                
                alertLog += `\n[選手: ${player}] (競合: ${competingTeams.join(', ')})\n -> 当選: ${winner}！\n`;

                await acquiredPlayersRef.child(winner).push(player);
                // 当選・落選のステータスをセット
                for (const teamId of competingTeams) {
                    if (teamId === winner) {
                        await teamStatusRef.child(teamId).set(`「${player}」の抽選に当選しました！`);
                    } else {
                        await teamStatusRef.child(teamId).set(`「${player}」の抽選に外れました。再度選択してください。`);
                    }
                }
            }
        }
        
        // 全チームの現在の選択をクリア
        await currentSelectionsRef.remove();

        // 巡目を進めるかどうかの判定
        if (Object.keys(conflicts).length > 0) {
            alert(alertLog + "\n抽選に外れたチームは、同じ巡で再度選手を選択してください。");
        } else {
            alert("競合はありませんでした。全チームの選択を確定し、次巡へ進みます。");
            const roundSnapshot = await roundRef.once('value');
            const nextRound = (roundSnapshot.val() || 1) + 1;
            await roundRef.set(nextRound);
            await teamStatusRef.remove(); // 次巡に進むのでステータスをクリア
        }
    }

    // リセット機能 (変更なし)
    async function resetAllData() {
        const confirmationText = "delete";
        const userInput = prompt(`警告：すべてのドラフトデータが完全に削除されます。「${confirmationText}」と入力してください。`);
        if (userInput === confirmationText) {
            await database.ref().set(null);
            await roundRef.set(1);
            alert("ドラフトデータが初期化されました。");
        } else if (userInput !== null) {
            alert("入力が間違っています。初期化はキャンセルされました。");
        }
    }
</script>
</body>
</html>