<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="robots" content="noindex">
<title>管理者画面</title>
<style>
	.box{max-width:1000px;margin:24px auto;padding:18px;border:1px solid #eee;border-radius:8px}
	.row{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap}
	.card{display:inline-block;padding:12px 16px;background:#17a2b8;color:#fff;border-radius:6px;text-decoration:none;font-weight:600}
	.card.back{background:#6c757d}
	.disabled{pointer-events:none;opacity:0.5}
	.notice{margin-top:12px;color:#d90429;font-weight:600}
	.section{margin-top:18px;padding-top:12px;border-top:1px dashed #ddd}
	.team-list, .acquired-list { margin:8px 0; padding-left: 18px; }
	.lottery-item { border:1px solid #ddd; padding:8px; margin:8px 0; border-radius:6px; }
	.small { padding:6px 10px; }
	.reset-button { background-color: #dc3545; margin-left: 15px; color:#fff; border:none; padding:6px 10px; border-radius:4px; }
	.lottery-button { background-color: #ffc107; color: black; border:none; padding:6px 10px; border-radius:4px; }
</style>
</head>
<body>
	<main class="box">
		<h1>管理者画面（ドラフト進行）</h1>
		<div class="row">
			<a id="setup-link" class="card" href="../setup/setup.html">セットアップ</a>
			<a id="home-link" class="card back" href="../home/index.html">ホーム</a>
		</div>

		<div id="admin-notice" class="notice" style="display:none;"></div>

		<div class="section">
			<h3>現在選択中の選手（第<span id="round-number">1</span>巡）</h3>
			<ul id="current-selection-list" class="team-list">読み込み中...</ul>
		</div>

		<div class="section">
			<h3>各チーム獲得選手一覧</h3>
			<ul id="acquired-players-list" class="acquired-list">読み込み中...</ul>
		</div>

		<div class="section">
			<h3>進行中のくじ</h3>
			<div id="lottery-status-container">読み込み中...</div>
		</div>

		<div class="section">
			<button id="process-btn" class="small">選択を処理</button>
			<button id="reset-btn" class="reset-button">ドラフトをリセット</button>
		</div>
	</main>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script src="../firebase-config.js"></script>
<script>
/* c:\Users\Haruto Arai\draft\admin\admin.html
   ...existing code... */
(function(){
	// firebaseConfig の確認
	if (typeof firebaseConfig === 'undefined') {
		console.error('firebaseConfig is not defined. Please place draft\\firebase-config.js');
		const n = document.getElementById('admin-notice');
		n.textContent = 'エラー: Firebase 設定が読み込まれていません。管理者に確認してください。';
		n.style.display = 'block';
		// disable controls
		document.querySelectorAll('button,a').forEach(el=>el.disabled=true);
		return;
	}
	if (!firebase.apps || !firebase.apps.length) firebase.initializeApp(firebaseConfig);
	const db = firebase.database();

	// refs
	const configRef = db.ref('draftConfig');
	const roundRef = db.ref('round');
	const currentSelectionsRef = db.ref('currentSelections');
	const acquiredRef = db.ref('acquiredPlayers');
	const lotteriesRef = db.ref('lotteries');
	const selectionConfirmedRef = db.ref('selectionConfirmed');
	const teamsPassedRef = db.ref('teamsPassed');
	const teamStatusRef = id => db.ref('teamStatus/' + id);
	const systemAlertRef = db.ref('systemAlert');

	// DOM
	const roundNumberEl = document.getElementById('round-number');
	const currentSelectionListEl = document.getElementById('current-selection-list');
	const acquiredPlayersListEl = document.getElementById('acquired-players-list');
	const lotteryStatusContainer = document.getElementById('lottery-status-container');
	const processBtn = document.getElementById('process-btn');
	const resetBtn = document.getElementById('reset-btn');
	const adminNoticeEl = document.getElementById('admin-notice');

	// runtime state
	let teams = [];            // team ids order
	let teamNames = {};        // id -> display name
	let waiverOrder = [];      // array of team ids (if provided)
	let currentSelectionsMap = {}; // latest currentSelections snapshot

	// load config (teams, candidates, waiverOrder)
	configRef.on('value', snap => {
		const cfg = snap.val() || {};
		teams = Array.isArray(cfg.teams) ? cfg.teams.map(t => t.id) : [];
		teamNames = {};
		(cfg.teams || []).forEach((t,i)=> teamNames[t.id] = t.name || `チーム${i+1}`);
		waiverOrder = Array.isArray(cfg.waiverOrder) ? cfg.waiverOrder.slice() : teams.slice();
		renderCurrentSelections(); // refresh display when team list changes
		renderAcquiredPlayers(); 
	});

	// round display
	roundRef.on('value', s => {
		roundNumberEl.textContent = s.val() || 1;
	});

	// current selections: update UI + auto-create lotteries for conflicts
	currentSelectionsRef.on('value', async snap => {
		currentSelectionsMap = snap.val() || {};
		renderCurrentSelections();

		// build player -> teams map
		const map = {};
		for (const teamId of Object.keys(currentSelectionsMap)) {
			const player = currentSelectionsMap[teamId];
			if (!player) continue;
			(map[player] || (map[player] = [])).push(teamId);
		}

		// create lotteries for players chosen by 2+ teams (skip if exists)
		for (const player in map) {
			const pickingTeams = map[player];
			if (pickingTeams.length < 2) continue;
			const exist = await lotteriesRef.child(encodeKey(player)).once('value');
			if (exist.exists()) continue;

			// pickOrder: waiverOrder filtered if available, otherwise random
			let pickOrder = waiverOrder.filter(t => pickingTeams.includes(t));
			if (!pickOrder.length) {
				pickOrder = pickingTeams.slice();
				// Fisher-Yates shuffle
				for (let i = pickOrder.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[pickOrder[i], pickOrder[j]] = [pickOrder[j], pickOrder[i]];
				}
			}

			const lots = pickingTeams.map((t,i)=>({ id:i, isPicked:false }));
			const payload = {
				competingTeams: pickingTeams.reduce((o,t)=>{ o[t]=true; return o; }, {}),
				lots,
				pickOrder,
				turnIndex: 0,
				picks: {},
				isRevealing: false
			};
			try {
				await lotteriesRef.child(encodeKey(player)).set(payload);
				console.log('Auto-created lottery for', player, 'teams', pickingTeams, 'order', pickOrder);
				await systemAlertRef.set(`選手「${player}」で競合が発生しました。抽選を行ってください。`);
			} catch (e) {
				console.error('lottery create failed', e);
			}
		}
	});

	// acquired players UI
	acquiredRef.on('value', snap => renderAcquiredPlayers(snap.val()));

	// lotteries UI
	lotteriesRef.on('value', snap => renderLotteryList(snap.val() || {}));

	// render helpers
	function renderCurrentSelections(){
		currentSelectionListEl.innerHTML = '';
		if (!teams.length) { currentSelectionListEl.textContent = 'チームが未設定です'; return; }
		// compute counts for highlighting conflicts
		const counts = {};
		Object.values(currentSelectionsMap).forEach(v => { if (v) counts[v] = (counts[v]||0)+1; });
		teams.forEach((teamId, i) => {
			const li = document.createElement('li');
			const player = currentSelectionsMap[teamId] || '未選択';
			const name = teamNames[teamId] || `チーム${i+1}`;
			li.textContent = `${name}: ${player}`;
			if (player !== '未選択' && counts[player] > 1) {
				li.style.color = '#d90429';
				li.title = 'この選手は複数チームが選択しています（くじ対象）';
			}
			currentSelectionListEl.appendChild(li);
		});
	}

	function renderAcquiredPlayers(val){
		acquiredPlayersListEl.innerHTML = '';
		const all = val || {};
		teams.forEach((teamId, i) => {
			const name = teamNames[teamId] || `チーム${i+1}`;
			const arr = all[teamId] ? Object.values(all[teamId]) : [];
			const li = document.createElement('li');
			li.textContent = `${name}: ${ arr.length ? arr.join(', ') : 'なし' }`;
			acquiredPlayersListEl.appendChild(li);
		});
	}

	function renderLotteryList(data){
		lotteryStatusContainer.innerHTML = '';
		const keys = Object.keys(data || {});
		if (!keys.length) { lotteryStatusContainer.textContent = '進行中のくじはありません'; return; }
		keys.forEach(playerKey => {
			const d = data[playerKey];
			const player = decodeKey(playerKey);
			const div = document.createElement('div'); div.className = 'lottery-item';
			const teamsIn = Object.keys(d.competingTeams || {});
			const picksCount = Object.keys(d.picks || {}).length;
			const pTitle = document.createElement('div'); pTitle.innerHTML = `<strong>選手: ${player}</strong>`;
			const pInfo = document.createElement('div'); pInfo.textContent = `競合: ${teamsIn.map(t=>teamNames[t]||t).join(', ')} ／ 抽選状況: ${picksCount}/${teamsIn.length}`;
			div.appendChild(pTitle); div.appendChild(pInfo);
			// reveal button appears when all picks done and not yet revealing
			if (picksCount === teamsIn.length && !d.isRevealing) {
				const btn = document.createElement('button');
				btn.className = 'lottery-button';
				btn.textContent = `「${player}」の抽選を開票`;
				btn.onclick = () => revealLotteryResults(playerKey);
				div.appendChild(btn);
			}
			lotteryStatusContainer.appendChild(div);
		});
	}

	// encode/decode key for player names to use as Firebase child keys
	function encodeKey(s){ return encodeURIComponent(s); }
	function decodeKey(k){ try { return decodeURIComponent(k); } catch(e){ return k; } }

	// processSelections triggered by admin button: assign non-conflicts, leave conflicts to lotteries
	processBtn.addEventListener('click', async ()=>{
		try {
			const selectionsSnap = await currentSelectionsRef.once('value');
			const selections = selectionsSnap.val() || {};
			const confirmedSnap = await selectionConfirmedRef.once('value');
			const confirmed = confirmedSnap.val() || {};
			const passedSnap = await teamsPassedRef.once('value');
			const passed = passedSnap.val() || {};
			// active teams: not passed and not yet confirmed
			const activeTeams = teams.filter(t => !(passed && passed[t]) && !(confirmed && confirmed[t]));
			// ensure all active teams have a selection (could be '未選択' as empty)
			for (const t of activeTeams) {
				if (!selections[t]) {
					return alert('まだ選択を終えていないチームがあります。');
				}
			}

			// build map player -> teams
			const map = {};
			for (const t of activeTeams) {
				const p = selections[t];
				(map[p] || (map[p]=[])).push(t);
			}

			const nonConflicts = [];
			const conflicts = {};
			for (const player in map) {
				if (map[player].length === 1) nonConflicts.push({ team: map[player][0], player });
				else conflicts[player] = map[player];
			}

			// assign non-conflicts
			for (const item of nonConflicts) {
				await acquiredRef.child(item.team).push(item.player);
				await teamStatusRef(item.team).set('交渉権獲得');
				await selectionConfirmedRef.child(item.team).set(true);
			}

			// create lotteries for conflicts if not exist
			for (const player in conflicts) {
				const pickingTeams = conflicts[player];
				const key = encodeKey(player);
				const exist = await lotteriesRef.child(key).once('value');
				if (exist.exists()) continue;
				// pick order via waiverOrder filtered or random
				let pickOrder = waiverOrder.filter(t=>pickingTeams.includes(t));
				if (!pickOrder.length) {
					pickOrder = pickingTeams.slice();
					for (let i=pickOrder.length-1;i>0;i--){
						const j = Math.floor(Math.random()*(i+1));
						[pickOrder[i], pickOrder[j]] = [pickOrder[j], pickOrder[i]];
					}
				}
				const lots = pickingTeams.map((t,i)=>({ id:i, isPicked:false }));
				await lotteriesRef.child(key).set({
					competingTeams: pickingTeams.reduce((o,t)=>{ o[t]=true; return o; }, {}),
					lots,
					pickOrder,
					turnIndex: 0,
					picks: {},
					isRevealing: false
				});
				await systemAlertRef.set(`選手「${player}」で競合が発生しました。抽選を行ってください。`);
			}

			// clear currentSelections for active teams (they will re-select if lost)
			for (const t of activeTeams) await currentSelectionsRef.child(t).remove();

			alert('選択処理を行いました。競合があるものは自動でくじが作成されます。');
		} catch (e) {
			console.error(e); alert('処理中にエラーが発生しました。コンソールを確認してください。');
		}
	});

	// revealLotteryResults: admin triggers opening/result assign
	async function revealLotteryResults(playerKey){
		try {
			const key = encodeKey(playerKey) === playerKey ? playerKey : encodeKey(decodeKey(playerKey));
			const snap = await lotteriesRef.child(key).once('value');
			const data = snap.val();
			if (!data) return alert('くじデータが取得できません');

			// mark revealing so clients show animation
			await lotteriesRef.child(key).child('isRevealing').set(true);

			// decide winner: if a winning lot marked exists use it; otherwise random by available picks
			let winnerTeam = null;
			// if picks exist (teams submitted picks), determine winner by which team picked winning lot id
			if (data.picks && Object.keys(data.picks).length) {
				// if server stored winning flag in lots use it; otherwise use current picks mapping and lots array
				const winningLot = (data.lots || []).find(l=>l.isWinner) || (data.lots && data.lots[Math.floor(Math.random() * data.lots.length)]);
				if (winningLot) {
					for (const teamId in data.picks) {
						if (data.picks[teamId] === winningLot.id) { winnerTeam = teamId; break; }
					}
				}
			}
			// fallback: random pick a competing team
			const teamsIn = Object.keys(data.competingTeams || {});
			if (!winnerTeam) winnerTeam = teamsIn[Math.floor(Math.random() * teamsIn.length)];

			// assign winner
			await acquiredRef.child(winnerTeam).push(decodeKey(key));
			for (const t of teamsIn) {
				if (t === winnerTeam) {
					await teamStatusRef(t).set('交渉権獲得');
					await selectionConfirmedRef.child(t).set(true);
				} else {
					await teamStatusRef(t).set('落選');
				}
			}

			// remove lottery after short delay to let clients animate
			setTimeout(()=> lotteriesRef.child(key).remove().catch(()=>{}), 2000);
			await systemAlertRef.remove();
			alert(`${teamNames[winnerTeam]||winnerTeam} を獲得者として確定しました。`);
		} catch (e) {
			console.error(e); alert('開票中にエラーが発生しました。');
		}
	}

	// reset all (destructive)
	resetBtn.addEventListener('click', async ()=>{
		const ok = prompt('警告: 全データを削除します。 delete と入力して実行してください');
		if (ok !== 'delete') { if (ok !== null) alert('入力が間違っています'); return; }
		try {
			await db.ref().set(null);
			await roundRef.set(1);
			alert('ドラフトデータを初期化しました。');
		} catch (e) {
			console.error(e); alert('リセットに失敗しました。');
		}
	});
})();
</script>
</body>
</html>